import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
import { Resend } from "npm:resend@4.0.0";
import { renderAsync } from 'npm:@react-email/components@0.0.22';
import React from 'npm:react@18.3.1';
import { InvitationEmail } from './_templates/invitation-email.tsx';

const resend = new Resend(Deno.env.get("RESEND_API_KEY"));

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

interface SendInvitationsRequest {
  emails: string[];
  role: string;
  custom_message?: string;
  expires_in_days?: number;
}

const handler = async (req: Request): Promise<Response> => {
  console.log('Send invitations request received');

  // Handle CORS preflight requests
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { 
      emails, 
      role, 
      custom_message = '',
      expires_in_days = 7 
    }: SendInvitationsRequest = await req.json();
    
    console.log(`Sending ${emails.length} invitations for role ${role}`);

    if (!emails || emails.length === 0) {
      throw new Error('Minst en e-postadress krävs');
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const invalidEmails = emails.filter(email => !emailRegex.test(email));
    
    if (invalidEmails.length > 0) {
      throw new Error(`Ogiltiga e-postadresser: ${invalidEmails.join(', ')}`);
    }

    const results = [];
    const errors = [];

    // Process each email
    for (const email of emails) {
      try {
        console.log(`Processing invitation for ${email}`);

        // Check if invitation already exists
        const { data: existingInvitation } = await supabaseClient
          .from('invitations')
          .select('id, token, status')
          .eq('email', email)
          .eq('status', 'pending')
          .maybeSingle();

        let invitation;
        
        if (existingInvitation) {
          console.log(`Found existing invitation for ${email}, using it`);
          invitation = existingInvitation;
        } else {
          console.log(`Creating new invitation for ${email}`);
          
          // Calculate expiry date
          const expiresAt = new Date();
          expiresAt.setDate(expiresAt.getDate() + expires_in_days);
          
          // Create new invitation with service role key
          const { data: newInvitation, error: createError } = await supabaseClient
            .from('invitations')
            .insert({
              email,
              invited_role: role,
              invited_by: '9065f42b-b9cc-4252-b73f-4374c6286b5e', // Admin user ID
              expires_at: expiresAt.toISOString(),
              token: '', // Will be generated by trigger
            })
            .select('id, token')
            .single();

          if (createError) {
            console.error(`Error creating invitation for ${email}:`, createError);
            errors.push(`${email}: ${createError.message}`);
            continue;
          }
          
          invitation = newInvitation;
        }

        if (!invitation?.token) {
          console.error(`No token found on invitation for ${email}:`, invitation);
          errors.push(`${email}: Inbjudan saknar token`);
          continue;
        }

        const appUrl = 'https://00a0d53e-45e2-45a5-8d70-ae3e74d84396.lovableproject.com';

        // Render the email template
        let html;
        try {
          html = await renderAsync(
            React.createElement(InvitationEmail, {
              invitedBy: 'Administratör',
              invitationToken: invitation.token,
              role: role === 'client' ? 'klient' : role === 'admin' ? 'administratör' : 'användare',
              appUrl,
              customMessage: custom_message,
            })
          );
        } catch (renderError) {
          console.error(`Error rendering email template for ${email}:`, renderError);
          // Fallback to simple HTML
          html = `
            <h1>Inbjudan till plattformen</h1>
            <p>Du har blivit inbjuden att gå med i plattformen som ${role === 'client' ? 'klient' : role === 'admin' ? 'administratör' : 'användare'}.</p>
            <p><a href="${appUrl}/invitation-signup?token=${invitation.token}">Klicka här för att acceptera inbjudan</a></p>
            ${custom_message ? `<p><strong>Meddelande:</strong> ${custom_message}</p>` : ''}
          `;
        }

        // Send the email
        const emailResponse = await resend.emails.send({
          from: "Plattformen <onboarding@resend.dev>",
          to: [email],
          subject: `Inbjudan till plattformen`,
          html,
        });

        if (emailResponse.error) {
          console.error(`Resend error for ${email}:`, emailResponse.error);
          
          // Check if this is API key issue, domain verification, or development restriction
          if (emailResponse.error.message?.includes('API key is invalid') ||
              emailResponse.error.message?.includes('testing emails') || 
              emailResponse.error.message?.includes('verify a domain') ||
              emailResponse.error.message?.includes('own email address')) {
            
            console.log(`Development mode for ${email}: Invitation created but email restricted`);
            
            results.push({
              email,
              success: true,
              invitation_id: invitation.id,
              invitation_token: invitation.token,
              invitation_url: `${appUrl}/invitation-signup?token=${invitation.token}`,
              dev_mode: true,
              note: 'För att skicka emails: Konfigurera RESEND_API_KEY och verifiera en domän på resend.com'
            });
          } else {
            errors.push(`${email}: ${emailResponse.error.message}`);
          }
        } else {
          console.log(`Invitation email sent successfully to ${email}:`, emailResponse);
          results.push({
            email,
            success: true,
            invitation_id: invitation.id,
            emailId: emailResponse.data?.id
          });
        }

      } catch (emailError: any) {
        console.error(`Error processing ${email}:`, emailError);
        errors.push(`${email}: ${emailError.message}`);
      }
    }

    // Return summary
    const totalSent = results.length;
    const totalErrors = errors.length;

    if (totalErrors === emails.length) {
      // All failed
      return new Response(
        JSON.stringify({ 
          error: `Alla inbjudningar misslyckades: ${errors.join('; ')}`
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json", ...corsHeaders },
        }
      );
    }

    const message = totalErrors > 0 
      ? `${totalSent} av ${emails.length} inbjudningar skickades. Fel: ${errors.join('; ')}`
      : `Alla ${totalSent} inbjudningar skickades framgångsrikt`;

    console.log("Invitations processing completed:", { totalSent, totalErrors });

    return new Response(JSON.stringify({ 
      success: totalSent > 0,
      message,
      results,
      errors: totalErrors > 0 ? errors : undefined,
      summary: {
        total: emails.length,
        sent: totalSent,
        failed: totalErrors
      }
    }), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        ...corsHeaders,
      },
    });
  } catch (error: any) {
    console.error("Error in send-invitations function:", error);
    return new Response(
      JSON.stringify({ 
        error: error.message || "Ett fel uppstod vid skickandet av inbjudningarna"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      }
    );
  }
};

serve(handler);